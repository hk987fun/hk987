<!DOCTYPE html>

<!--欢迎来到hk987，人类的进化就靠你了-->
 <!--
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░░ ░▒▓██████▓▒░░▒▓████████▓▒░ 
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░░░░░░▒▓█▓▒░ 
░▒▓████████▓▒░▒▓███████▓▒░░░▒▓███████▓▒░░▒▓██████▓▒░░░░░░▒▓█▓▒░  
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░░░░░░▒▓█▓▒░░░▒▓█▓▒░▒▓█▓▒░░░░░▒▓█▓▒░  
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░░░░░░▒▓█▓▒░░░▒▓█▓▒░▒▓█▓▒░░░░▒▓█▓▒░   
░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░░ ░▒▓██████▓▒░░░░▒▓█▓▒░
-->
<!--前进!不择手段的前进-->
<!--Copyright©hk987.xyz-->
<!--PC端Google和Firefox支持良好,移动端支持良好-->

<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0,user-scalable=no">
	<meta name="description" content="hk987-你在世俗里的名字不重要了">
	<meta name="author" content="hk987">
	<meta name="keywords" content="hk987,hk987.xyz,hack987,黑客987,黑客学习,Windows技术,Linux技术,Archlinux,Linux软件,漏洞挖掘,网络安全,渗透测试,自动化办公,python全自动办公,Windows系统激活,新手学电脑,IT技术,Rust,Rust编程,黑客技术,黑客,红客,honker,hack,hacker,网络安全,信息安全,网络安全学习,计算机小白,网安入门,网络安全入门,渗透测试,黑客技术,网络基础入门,操作系统,新手学电脑,小白学电脑,hack学习,hack入门,Windows基础,linux基础,Archlinux基础,Rust基础,Rust入门,Rust编程基础,黑客入门,Ubuntu入门,Manjaro,Endeavouros,红帽系统,centos基础学习,Rocky系统基础,Linux基础命令,Windows批处理,Windows安全,Linux安全,Kali基础,Kali渗透测试,KaliLinux,BlackArch,Github,加密解密,具体数学,线性代数,离散数学,红队攻防,蓝队攻防,黑客靶场练习,黑客靶场,黑客实战,hack实战,hack编程,黑客编程">
	<title>[Linux基础]-14-Linux硬盘分区管理 - hk987.xyz - www.hk987.xyz</title>
	<link rel="shortcut icon" type="image/x-icon" href="../logo/favicon.png">
	<link rel="stylesheet" type="text/css" href="../css/basic.css">
	<link rel="stylesheet" type="text/css" href="../css/home.css">
	<link rel="stylesheet" type="text/css" href="../css/text.css">
	<!--prism.js代码高亮模块-->
	<link rel="stylesheet" href="../css/prism.css" data-noprefix />
	<script src="../plugins/prism.js"></script>
	<!--/prism.js代码高亮模块-->
</head>
<body>
	<!--header -->
	<header id="nav">
			<div class="nav-container">
				<!-- 根大纲-->
				<a href="../index.html" title="Hk987首页">
					<h1 class="nav-logo">HK987 - hk987.xyz</h1>
				</a>
				<h2 class="nav-site-description desc-hidden">
					 S=−k∑pilnpi
				</h2>
				<nav class="nav-links">
					<!-- nav连接大纲-->
					<h1 style="display:none;">网站导航</h1>
					<ul>
						<li>
							<a href="../index.html" title="sitemap">
								<span class="link-word"><img src="../logo/archives.png" alt="archives" class="link-img"><span class="word-hidden">wiki</span></span>
							</a>
						</li>
					</ul>
				</nav>
			</div>
	</header>
	<!-- /header -->

	<!-- content-->
	<div id="content">
		<div class="content-container">
			<!-- 文章区 -->
			<article class="text-container">
				<header class="text-header">
					<h1>[Linux基础]-14-Linux硬盘分区管理</h1>	
				</header>
				<section class="text-body">
					<h2>引言</h2>
					<p>这篇文章介绍Linux系统中几个非常常用的硬盘分区管理命令。fdisk、gdisk、parted-- 硬盘分区管理等、mkfs -- 分区的格式化、mount -- 分区的挂载。</p>
					<!-- 目录 -->
					<h2>文章目录</h2>
					 <ul class="contents">	
						 <li><a href="#Linux-fdisk-1">0×1.Linux硬盘分区命名规则</a></li>
						 <li><a href="#Linux-fdisk-2">0×2.Linux使用fdisk对硬盘进行分区管理</a></li>
						 <li class="subli"><a href="#Linux-fdisk-3">a.使用fdisk查看硬盘以及分区信息</a></li>
						 <li class="subli"><a href="#Linux-fdisk-4">b.使用fdisk创建分区</a></li>
						 <li class="subli"><a href="#Linux-fdisk-5">c.使用fdisk改变分区文件系统类型</a></li>
						 <li class="subli"><a href="#Linux-fdisk-7">d.使用fdisk删除分区</a></li>
						 <li><a href="#Linux-gdisk-8">0×3.Linux使用gdisk对硬盘进行分区管理</a></li>
						 <li><a href="#Linux-mkfs-9">0×4.使用mkfs格式化分区</a></li>
						 <li><a href="#Linux-mount-10">0×5.使用mount挂载和卸载分区</a></li>
						 <li class="subli"><a href="#Linux-fstab-11">a.编辑/etc/fstab文件实现自动挂载</a></li>
						 <li><a href="#Linux-mkswap-12">0×6.Linux如何创建SWAP分区</a></li>
						 <li><a href="#Linux-parted-13">0×7.linux如何使用parted进行硬盘分区管理</a></li>
					 </ul>
					<!-- /目录 -->

					<!-- 正文 -->
					<h2 id="Linux-fdisk-1">0×1.Linux硬盘和分区命名规则</h2>
					
					<p>在Linux中，硬盘是以设备文件的形式存在的，设备文件一般是在"/dev/"目录中，而对不同接口的硬盘，目录中对应的名称前缀稍有不同，下面是几种常见接口的硬盘前缀，其中IDE硬盘已经慢慢淡出历史舞台：</p>
					<p class="indent-p">
						● IDE接口硬盘盘符前缀为hd：<br>
						/dev/hd[a-p]<br>
						例如计算机有两块IDE接口的硬盘，那第一块IDE硬盘设备文件名表示为：<br>
						/dev/hda<br>
						第一块硬盘的第1个分区号表示为：<br>
						/dev/hda1<br>
						第一块硬盘的第2个分区号表示为：<br>
						/dev/hda2<br>
						第二块设备文件名表示为：<br>
						/dev/hdb<br>
						第二块硬盘的第1个分区号表示为：<br>
						/dev/hdb1<br>
						以此类推；
					</p>
					<p class="indent-p">
						● SAS/SCSI/SATA/USB接口硬盘盘符前缀sd：<br>
						/dev/sd[a-p]<br>
						例如计算机有两块SATA接口的硬盘，那第一块SATA硬盘设备文件名称表示为：<br>
						/dev/sda<br>
						第一块硬盘的第1个分区号表示为：<br>
						/dev/sda1<br>
						第二块SATA硬盘设备文件名称表示为：<br>
						/dev/sdb<br>
						以此类推；
					</p>
					<p class="indent-p">
						● NVMe-M.2接口硬盘通过NVMe协议连接时盘符前缀为nvme：<br>
						/dev/nvme[0-x]n[0-x]（x是大于0的整数）<br>
						在部分机器中，同一个NVMe接口可以上下叠插两块M.2硬盘，假设这个接口被系统识别成0号nvme接口<br>
						那么这两块硬盘号就分别是：/dev/nvme0n1、/dev/nvme0n2，nvme后面的数字0代表了是0号接口<br>
						n后面的数字代表第1块硬盘和第2块硬盘<br>
						如果一个nvme接口只能插一块M.2硬盘，主板上存在两个nvme接口，那么第一个接口就是nvme0，第二个接口就是nvme1<br>
						例如计算机有两个NVMe协议接口分别是nvme0和nvme1，那第一块NVMe硬盘设备文件名称表示为：<br>
						/dev/nvme0n1<br>
						与SCSI和IDE命名规则不同，nvme的分区号用p表示，第一块nvme硬盘的第1个分区表示为：<br>
						/dev/nvme0n1p1<br>
						第一块nvme硬盘的第2个分区表示为：<br>
						/dev/nvme0n1p2<br>
						第二块NVMe硬盘设备文件名称表示为：<br>
						/dev/nvme1n1<br>
						以此类推；
					</p>
					<p>例外：当M.2硬盘通过SATA协议连接时，它通常会被识别为一个SATA设备，命名规则同SATA硬盘前缀为sd，什么时候会通过SATA协议连接？当使用显卡插槽的硬盘扩充卡的时候，就会使用SATA线连接。</p>

					<p>当了解了上面这些基础知识之后，我们同时也知道硬盘在linux中都作为文件存在/dev目录中，那么我们就能够通过下面的方法来查看我们都安装了哪些硬盘：</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#首先查看dev下面的sd开头的设备，也就是SAS/SCSI/SATA/USB接口的存储设备
					#从命令的输出可以判断，电脑内安装了sda、sdb、sdc、sdd这四块SAS/SCSI/SATA/USB接口的存储设备
					#其中sda又被分了三个分区，分别是sda1、sda2、sda3
					#sdb、sdc、sdd分别各有一个分区，sdb1、sdc1、sdd1
					987@hk987.xyz:~$ ls /dev/sd*
					/dev/sda  /dev/sda1  /dev/sda2  /dev/sda3  /dev/sdb  /dev/sdb1  /dev/sdc  /dev/sdc1  /dev/sdd  /dev/sdd1

					#电脑中没有使用IDE接口的储存设备，所以输出就没有找到任何hd开头的文件
					987@hk987.xyz:~$ ls /dev/hd*
					bash: no matches found: /dev/hd*

					#电脑中安装了两块NVMe-M2接口的储存设备：nvme0n1、nvme1n1
					#其中第一块nvme划分了三个分区，分别是nvme0n1p1、nvme0n1p2、nvme0n1p3
					#第二块nvme划分了一个分区nvme1n1p1
					987@hk987.xyz:~$ ls /dev/nvme*
					/dev/nvme0  /dev/nvme0n1  /dev/nvme0n1p1  /dev/nvme0n1p2  /dev/nvme0n1p3  /dev/nvme1  /dev/nvme1n1  /dev/nvme1n1p1

					#除了ls命令直接查看外，还可以使用lsblk命令来查看
					987@hk987.xyz:~$ lsblk
					</code>
					</pre>
					<p>这样我们从设备文件的角度去观察，就已经掌握了电脑硬件中存在的存储设备数量，以及它们的接口类型，接下来介绍的另外一个命令，能够对这些类型的存储设备进行分区和管理。</p>

					<h2 id="Linux-fdisk-2">0×2.使用fdisk对硬盘进行管理</h2>
					<p>实验环境为VMware中的Rockylinux-9，为了实例演示上面介绍的内容，在VMware中，添加了三块硬盘，如下：</p>
					<p class="indent-p">
						● 20G -- 接口NVMe-M2
					</p>
					<p class="indent-p">
						● 30G -- 接口IDE
					</p>
					<p class="indent-p">
						● 40G -- 接口SCSI
					</p>
					<p>！！！注意！！！NVMe-M2类型的硬盘只能在虚拟机关机状态下添加，硬盘添加好后，如果开机黑屏，对于Linux虚拟机，建议将虚拟机设置中的显卡3D取消勾选，否则容易开机黑屏bug；还有一种情况是提示找不到系统，需要在虚拟机BIOS里面将系统所在盘调到第一位。</p>
					<h3 id="Linux-fdisk-3">a.使用fdisk查看硬盘以及分区信息</h3>
					<p>开机进入系统后，使用fdisk来对上面添加的三块硬盘进行分区操作。</p>
					<p>fdisk是Linux下面的一个硬盘管理命令。可以查看当前环境有几块硬盘，每块硬盘的大小，每块硬盘上都划分了那些区域，还可以对硬盘进行分区、删除、改变分区文件系统类型等操作：</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#对硬盘的操作需要root权限，使用sudo执行命令，查看当前环境下硬盘的全局信息
					987@hk987.xyz:~$ sudo fdisk -l
					[sudo] hk987 的密码：
					#这是系统盘/dev/nvme0n1的综合信息，部分字段解释如下:
					#通过Disk后面的名称可以判断，这是一个NVMe类型的硬盘，总大小200 GB；

					Disk /dev/nvme0n1：200 GiB，214748364800 字节，419430400 个扇区
					磁盘型号：VMware Virtual NVMe Disk
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：dos
					磁盘标识符：0xf4786abb

					#Device下面显示的是设备分区号，Boot下面带*号的是引导分区；
					#Start和End是起始和结束的磁柱，通过起始和结束磁柱可以计算Blocks大小，计算方法(End-Start)*(Units/1024)小数点四舍五入；
					#Id是系统对文件系统的编号(83=Linux文件系统ext，7=NTFS文件系统，8e=Linux LVM)；
					#System是文件系统的名称和ID对应，文件系统编号稍后会介绍到；
					Device              Boot  Start     End          Blocks                Id   System
					设备                  启动    起点      末尾          扇区       大小     Id   类型
					/dev/nvme0n1p1 *    2048   2099199   2097152      1G      83  Linux
					/dev/nvme0n1p2      2099200 419430399 417331200  199G 8e  Linux LVM

					#下面三个看到的，就是我们自己添加的三块硬盘
					#20G的nvme类型硬盘，还没有分区
					Disk /dev/nvme0n2：20 GiB，21474836480 字节，41943040 个扇区
					磁盘型号：VMware Virtual NVMe Disk
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节

					#30G的IDE接口类型硬盘，在虚拟机中IDE接口也会被识别成sd开头的设备，但是磁盘型号会显示成I，说明硬盘接口是IDE
					#在生产环境中，这个磁盘型号会显示硬盘品牌名称，例如“磁盘型号：WD Blue SN570 1TB SSD ”
					Disk /dev/sda：30 GiB，32212254720 字节，62914560 个扇区
					磁盘型号：VMware Virtual I
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节

					#40G的SCSI接口类型硬盘，磁盘型号显示的是S
					Disk /dev/sdb：40 GiB，42949672960 字节，83886080 个扇区
					磁盘型号：VMware Virtual S
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节

					#下面这三个，其实就是我们上面那块安装系统的200G硬盘划分出来的卷组，卷组的概念会在Linux进阶篇中介绍
					Disk /dev/mapper/rl-root：70 GiB，75161927680 字节，146800640 个扇区
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节

					Disk /dev/mapper/rl-swap：7.84 GiB，8417968128 字节，16441344 个扇区
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节

					Disk /dev/mapper/rl-home：121.16 GiB，130090532864 字节，254083072 个扇区
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					</code>
					</pre>

					<h3 id="Linux-fdisk-4">b.使用fdisk创建分区</h3>

					<p>★ 下面是fdisk命令的使用帮助信息</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#进入/dev/nvme0n2这块硬盘的命令模式
					#通过前面的介绍我们知道，虚拟机中的M.2硬盘，都是这种叠插模式
					#相当于在nvme0号接口上可以插入N多个M.2硬盘
					987@hk987.xyz:~$ sudo fdisk /dev/nvme0n2
					#输入m回车后可查看命令帮助
					命令(输入 m 获取帮助)：m
					帮助：
					  DOS (MBR)
					   a   开关 可启动 标志
					   b   编辑嵌套的 BSD 磁盘标签
					   c   开关 dos 兼容性标志
					  常规
					   d   删除分区
					   F   列出未分区的空闲区
					   l   列出已知分区类型
					   n   添加新分区
					   p   打印分区表
					   t   更改分区类型
					   v   检查分区表
					   i   打印某个分区的相关信息
					  杂项
					   m   打印此菜单
					   u   更改 显示/记录 单位
					   x   更多功能(仅限专业人员)
					  脚本
					   I   从 sfdisk 脚本文件加载磁盘布局
					   O   将磁盘布局转储为 sfdisk 脚本文件
					  保存并退出
					   w   将分区表写入磁盘并退出
					   q   退出而不保存更改
					  新建空磁盘标签
					   g   新建一份 GPT 分区表
					   G   新建一份空 GPT (IRIX) 分区表
					   o   新建一份的空 DOS 分区表
					   s   新建一份空 Sun 分区表

					#上面是fdisk支持的全部命令，下面是几个常用命令的解释：
					# g 新建gpt分区表；
					# d 删除一个分区；
					# l 显示一个分区文件类型列表，在这个列表会看所有的分区文件类型所对应的数字（传统MBR分区模式适用）；
					# t 改变分区类型（传统MBR分区模式适用）；
					# m 列出帮助信息；
					# n 新建一个分区；
					# p 列出分区表（fdisk -l是显示所有硬盘的分区表，这里的p是显示当前硬盘的分区表）；
					# w 保存当前操作然后退出；
					# q 不保存退出；
					</code>
					</pre>
					<p>！！！注意！！！</p>
					<p>在使用 fdisk命令进行硬盘分区时，当你选择了g来创建GPT（GUID Partition Table）分区表后， <br>
					fdisk就会自动使用GPT格式来分区，而不是使用传统的MBR（Master Boot Record）格式，<br>
					在GPT分区表中，没有"主分区"的概念，所有的分区都是“分区”，没有主分区和扩展分区的区别。</p>

					<p>下面分别用GPT和MBR两种格式来创建分区，分别演示</p>
					<p>★ 使用GPT格式创建分区（推荐）</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#使用g命令，创建GPT分区表
					命令(输入 m 获取帮助)：g     
					已创建新的 GPT 磁盘标签(GUID: 9E261226-7289-F846-ABC5-370150C140F6)。

					命令(输入 m 获取帮助)：n   #使用n命令创建分区
					分区号 (1-128, 默认  1):  #默认分区号是1，可以手动输入分区号
					第一个扇区 (2048-41943006, 默认 2048):  #默认从第一个扇区开始分配空间，回车即可
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (2048-41943006, 默认 41943006): +5G #创建一个大小为5G的分区

					创建了一个新分区 1，类型为“Linux filesystem”，大小为 5 GiB。

					命令(输入 m 获取帮助)：p #通过p查看刚才创建的分区
					Disk /dev/nvme0n2：20 GiB，21474836480 字节，41943040 个扇区
					磁盘型号：VMware Virtual NVMe Disk
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：gpt
					磁盘标识符：9E261226-7289-F846-ABC5-370150C140F6

					设备            起点     末尾     扇区 大小 类型
					/dev/nvme0n2p1  2048 10487807 10485760   5G Linux 文件系统

					#重复上面的操作，创建一个大小是200M的分区
					命令(输入 m 获取帮助)：n
					分区号 (2-128, 默认  2): 
					第一个扇区 (10487808-41943006, 默认 10487808): 
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (10487808-41943006, 默认 41943006): +200M

					创建了一个新分区 2，类型为“Linux filesystem”，大小为 200 MiB。

					命令(输入 m 获取帮助)：p
					Disk /dev/nvme0n2：20 GiB，21474836480 字节，41943040 个扇区
					磁盘型号：VMware Virtual NVMe Disk
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：gpt
					磁盘标识符：9E261226-7289-F846-ABC5-370150C140F6

					设备               起点     末尾     扇区  大小 类型
					/dev/nvme0n2p1     2048 10487807 10485760    5G Linux 文件系统
					/dev/nvme0n2p2 10487808 10897407   409600  200M Linux 文件系统

					#再次重复上面的操作，这一次，将剩下的所有空间都分配给分区3，因为都是使用默认值，所以不需要输入，全部回车即可
					命令(输入 m 获取帮助)：n
					分区号 (3-128, 默认  3): 
					第一个扇区 (10897408-41943006, 默认 10897408): 
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (10897408-41943006, 默认 41943006): 

					创建了一个新分区 3，类型为“Linux filesystem”，大小为 14.8 GiB。

					命令(输入 m 获取帮助)：p
					Disk /dev/nvme0n2：20 GiB，21474836480 字节，41943040 个扇区
					磁盘型号：VMware Virtual NVMe Disk
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：gpt
					磁盘标识符：9E261226-7289-F846-ABC5-370150C140F6

					设备               起点     末尾     扇区  大小 类型
					/dev/nvme0n2p1     2048 10487807 10485760    5G Linux 文件系统
					/dev/nvme0n2p2 10487808 10897407   409600  200M Linux 文件系统
					/dev/nvme0n2p3 10897408 41943006 31045599 14.8G Linux 文件系统

					#如果你对上面的分区满意，使用w写入分区表再退出，如果不满意，可以使用q不保存退出
					命令(输入 m 获取帮助)：w
					分区表已调整。
					将调用 ioctl() 来重新读分区表。
					正在同步磁盘。
					</code>
					</pre>
					<p>★ 使用MBR格式创建分区</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#用第二块30G的硬盘来演示
					987@hk987.xyz:~$ sudo fdisk /dev/sda
					[sudo] hk987 的密码：
					#不使用g命令直接使用n命令创建分区，就会默认使用MBR格式分区表
					命令(输入 m 获取帮助)：n
					分区类型
					   p   主分区 (0 primary, 0 extended, 4 free)
					   e   扩展分区 (逻辑分区容器)
					选择 (默认 p)：p #创建一个主分区
					分区号 (1-4, 默认  1):  #默认分区号1，直接回车就行
					第一个扇区 (2048-62914559, 默认 2048):  #默认从第一个扇区开始分配，默认回车
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (2048-62914559, 默认 62914559): +6G #分配一个6G的主分区

					创建了一个新分区 1，类型为“Linux”，大小为 6 GiB。

					#再分配一个扩展分区
					#在这里要补充一个概念，在MBR格式的分区表中，只能存在4个主分区，1个扩展分区
					#1个扩展分区也占用1个主分区号，这就意味着，我们最多只能分配3个主分区和1个扩展分区
					#主分区号的范围是1~4，就算没有那么多主分区，分区号也会保留着
					#而逻辑分区的分区号是从5开始的，逻辑分区是在扩展分区这个容器中分配出来的分区
					#如果三个主分区和一个扩展分区全部分配出来后，磁盘还有多余的空间，这一部分多出来的将不可用
					#所以用MBR格式的分区表的时候，一定要在分配分区的时候将磁盘空间全部划分上
					命令(输入 m 获取帮助)：n
					分区类型
					   p   主分区 (1 primary, 0 extended, 3 free)
					   e   扩展分区 (逻辑分区容器)
					选择 (默认 p)：e
					分区号 (2-4, 默认  2):  #默认回车
					第一个扇区 (12584960-62914559, 默认 12584960):  #默认回车
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (12584960-62914559, 默认 62914559): +10G #假设我这里只给扩展分区10G空间

					创建了一个新分区 2，类型为“Extended”，大小为 10 GiB。

					#查看一下当前分配的分区表，可以看到主分区占用的分区号是sda1，扩展分区占用的主分区号是sda2
					命令(输入 m 获取帮助)：p
					Disk /dev/sda：30 GiB，32212254720 字节，62914560 个扇区
					磁盘型号：VMware Virtual I
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：dos
					磁盘标识符：0x22e62e62

					设备       启动     起点     末尾     扇区 大小 Id 类型
					/dev/sda1           2048 12584959 12582912   6G 83 Linux
					/dev/sda2       12584960 33556479 20971520  10G  5 扩展

					#在这个基础上，再分配逻辑分区
					#逻辑分区就是从扩展分区中划分空间得到的分区，逻辑分区号是从5开始的
					#并且我们挂载分区的时候，扩展分区是无法挂载的，它只是逻辑分区的一个容器
					命令(输入 m 获取帮助)：n
					分区类型
					   p   主分区 (1 primary, 1 extended, 2 free)
					   l   逻辑分区 (从 5 开始编号)
					选择 (默认 p)：l

					添加逻辑分区 5
					第一个扇区 (12587008-33556479, 默认 12587008):  #回车
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (12587008-33556479, 默认 33556479): +5G #分配5G

					创建了一个新分区 5，类型为“Linux”，大小为 5 GiB。

					命令(输入 m 获取帮助)：p
					Disk /dev/sda：30 GiB，32212254720 字节，62914560 个扇区
					磁盘型号：VMware Virtual I
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：dos
					磁盘标识符：0x22e62e62

					设备       启动     起点     末尾     扇区 大小 Id 类型
					/dev/sda1           2048 12584959 12582912   6G 83 Linux
					/dev/sda2       12584960 33556479 20971520  10G  5 扩展
					/dev/sda5       12587008 23072767 10485760   5G 83 Linux

					#重复上面的操作，分配扩展分区剩下的空间
					命令(输入 m 获取帮助)：n
					分区类型
					   p   主分区 (1 primary, 1 extended, 2 free)
					   l   逻辑分区 (从 5 开始编号)
					选择 (默认 p)：l

					添加逻辑分区 6
					第一个扇区 (23074816-33556479, 默认 23074816): 
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (23074816-33556479, 默认 33556479): 

					创建了一个新分区 6，类型为“Linux”，大小为 5 GiB。

					命令(输入 m 获取帮助)：p
					Disk /dev/sda：30 GiB，32212254720 字节，62914560 个扇区
					磁盘型号：VMware Virtual I
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：dos
					磁盘标识符：0x22e62e62

					设备       启动     起点     末尾     扇区 大小 Id 类型
					/dev/sda1           2048 12584959 12582912   6G 83 Linux
					/dev/sda2       12584960 33556479 20971520  10G  5 扩展
					/dev/sda5       12587008 23072767 10485760   5G 83 Linux
					/dev/sda6       23074816 33556479 10481664   5G 83 Linux

					#因为我们上面对扩展分区分配的空间是10G，所以上面两个逻辑分区sda5和sda6已经占用了所有的扩展分区空间
					#我们再去分配一个逻辑分区的时候，就会显示没有剩余空间可用了
					#如果想要用完这块硬盘的所有空间，就只能分配主分区
					#并且MBR格式的分区表只能存在一个扩展分区
					命令(输入 m 获取帮助)：n
					分区类型
					   p   主分区 (1 primary, 1 extended, 2 free)
					   l   逻辑分区 (从 5 开始编号)
					选择 (默认 p)：l

					添加逻辑分区 7
					无空闲扇区可用。

					#为了完整演示占完所有空间的分区方式，我先用q不保存退出，重新分区
					命令(输入 m 获取帮助)：q

					987@hk987.xyz:~$ sudo fdisk /dev/sda

					命令(输入 m 获取帮助)：n
					分区类型
					   p   主分区 (0 primary, 0 extended, 4 free)
					   e   扩展分区 (逻辑分区容器)
					选择 (默认 p)：p
					分区号 (1-4, 默认  1): 
					第一个扇区 (2048-62914559, 默认 2048): 
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (2048-62914559, 默认 62914559): +10G #主分区分10G

					创建了一个新分区 1，类型为“Linux”，大小为 10 GiB。

					命令(输入 m 获取帮助)：n
					分区类型
					   p   主分区 (1 primary, 0 extended, 3 free)
					   e   扩展分区 (逻辑分区容器)
					选择 (默认 p)：e
					分区号 (2-4, 默认  2): 
					第一个扇区 (20973568-62914559, 默认 20973568): 
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (20973568-62914559, 默认 62914559):  #创建扩展分区默认用完所有空间，直接回车

					创建了一个新分区 2，类型为“Extended”，大小为 20 GiB。

					命令(输入 m 获取帮助)：p
					Disk /dev/sda：30 GiB，32212254720 字节，62914560 个扇区
					磁盘型号：VMware Virtual I
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：dos
					磁盘标识符：0xa4f037d4

					设备       启动     起点     末尾     扇区 大小 Id 类型
					/dev/sda1           2048 20973567 20971520  10G 83 Linux
					/dev/sda2       20973568 62914559 41940992  20G  5 扩展

					#这样我们在这个20G的扩展分区容器中，再去创建逻辑分区，就能用完这块硬盘的所有空间了
					命令(输入 m 获取帮助)：n
					所有主分区的空间都在使用中。
					添加逻辑分区 5
					第一个扇区 (20975616-62914559, 默认 20975616): 
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (20975616-62914559, 默认 62914559): +5G

					创建了一个新分区 5，类型为“Linux”，大小为 5 GiB。

					命令(输入 m 获取帮助)：n
					所有主分区的空间都在使用中。
					添加逻辑分区 6
					第一个扇区 (31463424-62914559, 默认 31463424): 
					最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (31463424-62914559, 默认 62914559): 

					创建了一个新分区 6，类型为“Linux”，大小为 15 GiB。

					命令(输入 m 获取帮助)：p
					Disk /dev/sda：30 GiB，32212254720 字节，62914560 个扇区
					磁盘型号：VMware Virtual I
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：dos
					磁盘标识符：0xa4f037d4

					设备       启动     起点     末尾     扇区 大小 Id 类型
					/dev/sda1           2048 20973567 20971520  10G 83 Linux
					/dev/sda2       20973568 62914559 41940992  20G  5 扩展
					/dev/sda5       20975616 31461375 10485760   5G 83 Linux
					/dev/sda6       31463424 62914559 31451136  15G 83 Linux

					命令(输入 m 获取帮助)：w
					分区表已调整。
					将调用 ioctl() 来重新读分区表。
					正在同步磁盘。
					</code>
					</pre>

					<h3 id="Linux-fdisk-5">c.使用fdisk改变分区文件系统类型（MBR格式分区表适用）</h3>
					<p>这一部分的内容，适用于MBR格式的分区表，在GPT格式的分区表中，分区的类型是由mkfs格式化决定的，不需要额外的指定分区的文件系统类型。</p>
					<p>MBR格式分区改变分区文件系统类型：</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#再次进入这块硬盘的命令模式
					987@hk987.xyz:~$ sudo fdisk /dev/sda

					Command (m for help): l #输入l查看当前可用的文件系统类型
					...
					 6  FAT16
					 7  HPFS/NTFS

					#将主分区改成NTFS文件系统
					命令(输入 m 获取帮助)：t
					#输入要改变的分区号，输入了1
					分区号 (1,2,5,6, 默认  6): 1
					#输入上面
					Hex 代码或别名（输入 L 列出所有代码）：7

					已将分区“Linux”的类型更改为“HPFS/NTFS/exFAT”。

					#用p查看到主分区sda1的类型已经变成了NTFS
					命令(输入 m 获取帮助)：p

					Disk /dev/sda：30 GiB，32212254720 字节，62914560 个扇区
					磁盘型号：VMware Virtual I
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：dos
					磁盘标识符：0xa4f037d4

					设备       启动     起点     末尾     扇区 大小 Id 类型
					/dev/sda1           2048 20973567 20971520  10G  7 HPFS/NTFS/exFAT
					/dev/sda2       20973568 62914559 41940992  20G  5 扩展
					/dev/sda5       20975616 31461375 10485760   5G 83 Linux
					/dev/sda6       31463424 62914559 31451136  15G 83 Linux

					命令(输入 m 获取帮助)：w #保存退出
					分区表已调整。
					将调用 ioctl() 来重新读分区表。
					正在同步磁盘。
					</code>
					</pre>

					<h3 id="Linux-fdisk-7">d.使用fdisk删除分区</h3>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					987@hk987.xyz:~$ sudo fdisk /dev/sda
					#使用d命令删除分区
					命令(输入 m 获取帮助)：d
					分区号 (1,2,5,6, 默认  6): 6

					分区 6 已删除。

					命令(输入 m 获取帮助)：p
					Disk /dev/sda：30 GiB，32212254720 字节，62914560 个扇区
					磁盘型号：VMware Virtual I
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：dos
					磁盘标识符：0xa4f037d4

					设备       启动     起点     末尾     扇区 大小 Id 类型
					/dev/sda1           2048 20973567 20971520  10G  7 HPFS/NTFS/exFAT
					/dev/sda2       20973568 62914559 41940992  20G  5 扩展
					/dev/sda5       20975616 31461375 10485760   5G 83 Linux
					
					#保存刚才的删除操作（慎用，分区删除之后找不回来）
					命令(输入 m 获取帮助)：w
					分区表已调整。
					将调用 ioctl() 来重新读分区表。
					正在同步磁盘。
					</code>
					</pre>
					<p>分区完成后就可以对分区进行格式化操作了，只有被格式化之后，这个分区才能被挂载使用，部分发行版格式化前必须重启系统，新建的分区才能被识别（不同的系统可能不一样，一部分Linux发行版分区完成后直接就能格式化无需重启）。</p>

					<h2 id="Linux-gdisk-8">0×3.Linux使用gdisk对硬盘进行分区管理</h2>

					<p>gdisk 是一种用于管理和操作 GPT (GUID Partition Table) 分区表的命令行工具。它与 fdisk 类似，但 fdisk 目前最大仅支持最大2TB的硬盘进行分区管理，而 gdisk 可以支持超过2TB的硬盘，并且gdisk的操作命令与fdisk相同。</p>

					<p>唯一的缺点是无法通过gdisk -l这个命令来显示主机安装了哪些硬盘，所以还需要配合fdisk或者lsblk命令一起使用。</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#首先通过fdisk查看我们需要操作的硬盘
					987@hk987.xyz:~$ sudo fdisk -l
					#假设我们需要操作20G这块M.2硬盘
					987@hk987.xyz:~$ sudo gdisk /dev/nvme0n2
					Command (? for help): o    #输入o可以新建GPT分区表，注意gdisk不支持MBR
					Proceed? (Y/N): Y    #输入Y，这个操作会将旧的分区全部删除（！）

					#剩下的操作和fdisk命令大同小异
					Command (? for help): n  #创建新的分区
					Partition number (1-128, default 1):  #直接回车，默认分区号从1开始
					First sector (34-41943006, default = 2048) or {+-}size{KMGTP}:  #直接回车，从第一个扇区开始分区
					Last sector (2048-41943006, default = 41943006) or {+-}size{KMGTP}: +5G  #分配5G大小给第一个分区
					Current type is 8300 (Linux filesystem)
					Hex code or GUID (L to show codes, Enter = 8300):  #直接回车，默认的文件系统为Linux fs
					Changed type of partition to 'Linux filesystem'

					Command (? for help): p  #查看分区表
					Number  Start (sector)    End (sector)  Size       Code  Name
					   1            2048        10487807   5.0 GiB     8300  Linux filesystem

					 #用同样的方法可以创建分区2..3等，这里就不再赘述了，值得注意的是，如果想要创建Windows可以识别的分区类型，Hex code需要输入0700，即为0700 Microsoft basic data文件系统
					</code>
					</pre>

					<h2 id="Linux-mkfs-9">0×4.使用mkfs格式化分区</h2>

					<p>★ 将分区格式化成windows适用的NTFS格式</p>
					<p>注意：ntfs-3g包可能不在默认的yum\dnf仓库中，这就意味着mkfs命令没有NTFS这种windows系统支持的分区格式，但可以尝试通过下面的方法，使用EPEL（Extra Packages for Enterprise Linux）仓库来安装 ntfs-3g。</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#在Rocky-9中默认是没有NTFS格式的，需要手动添加，首先安装EPEL仓库
					987@hk987.xyz:~$ sudo dnf install epel-release

					#然后安装ntfs-3g和ntfsprogs
					#mkfs.ntfs在部分发行版中包含在ntfs-3g这个软件包中，也可能包含在ntfsprogs中
					#在rocky的EPEL仓库中，mkfs.ntfs包含在ntfsprogs中
					#所以推荐两个都装上
					987@hk987.xyz:~$ sudo dnf install -y ntfs-3g ntfsprogs

					#假设我们将上面的/dev/sda1分区格式化成NTFS格式，可以这样做
					987@hk987.xyz:~$ sudo mkfs.#在这个.后面连续按两下tab键，下面就是mkfs支持的格式化类型
					mkfs.btrfs   mkfs.ext2    mkfs.ext4    mkfs.ntfs   mkfs.vfat    
					mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.xfs

					#将/dev/sda1格式化成NTFS文件系统，-f命令执行快速格式化
					987@hk987.xyz:~$ sudo mkfs.ntfs -f /dev/sda1
					</code>
					</pre>

					<p>★ 将分区格式化成Linux适用的格式</p>
					<p>虽然NTFS格式的分区在Linux上也能正常读取（需要安装ntfs-3g和ntfsprogs软件包支持），但是对于Linux来说，原生的分区格式才能发挥Linux的特性，加快读取速度，下面演示将/dev/nvme0n2p3格式化成Linux支持的Ext4文件系统：</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#mkfs命令中除了ext格式外，xfs也是Linux原生支持的分区格式，特别适用于大容量的磁盘
					987@hk987.xyz:~$ sudo mkfs.ext4 /dev/nvme0n2p3
					</code>
					</pre>

					<h2 id="Linux-mount-10">0×5.使用mount挂载分区</h2>
					<p>★ 使用分区名称来挂载</p>
					<p>使用下面的命令，将/dev/sda1挂载到/home/987/sda1：</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#在自己的家目录创建一个文件夹sda1
					987@hk987.xyz:~$ mkdir ~/sda1 

					#将/dev/sda1分区挂载到刚才创建的文件夹中
					987@hk987.xyz:~$ sudo mount /dev/sda1 ~/sda1

					#因为挂载操作是root权限的，所以挂载后sda1目录会变成只有root才能读写
					#当前用户需要读写请使用下面的命令将这个目录的用户和组都改为当前用户
					#本例中mm是我的用户名，使用时请将mm替换成你自己的用户名
					987@hk987.xyz:~$ sudo chown -R 987:987 ~/sda1

					#如果不需要使用了，可以使用下面的命令取消挂载
					987@hk987.xyz:~$ sudo umount ~/sda1
					</code>
					</pre>
					<p>挂载完成后，对目录~/sda1的读写操作实际上就是直接读写的/dev/sda1这个逻辑分区，但系统重启后，挂载会失效，可以使用下面的方法来让系统自动挂载。</p>

					<p>★ 使用分区UUID来挂载</p>
					<p>因为在使用过程中，可能会出现硬盘损坏，或者替换硬盘等情况，会导致硬盘分区号发生改变（例如sdb硬盘因为sda硬盘的损坏，在下次重启后可能被系统自动识别成sda硬盘，这样使用分区名称的方式挂载sdb就会找不到sdb硬盘），从而让挂载失效，使用分区的UUID（Universally Unique Identifier，通用唯一标识符）来挂载分区是一种更可靠和稳定的方法，因为UUID在分区创建时被分配，不会因为分区号的改变而改变。</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#查看当前系统中有哪些分区以及UUID号
					987@hk987.xyz:~$ sudo blkid
					[sudo] hk987 的密码：
					/dev/mapper/rl-swap: UUID="a7978913-fbc3-44fa-a6d0-2f536411d7a0" TYPE="swap"
					/dev/nvme0n1p1: UUID="e6180a1d-4211-433e-af76-51c25f3167d5" TYPE="xfs" PARTUUID="f4786abb-01"
					/dev/nvme0n1p2: UUID="RhaEmp-g1fF-8QJc-3qNz-wcTv-CL1Q-gLOqFo" TYPE="LVM2_member" PARTUUID="f4786abb-02"
					/dev/sda5: PARTUUID="a4f037d4-05"

					/dev/sda1: UUID="6510A6455A6F759A" TYPE="ntfs" PARTUUID="a4f037d4-01"

					/dev/mapper/rl-home: UUID="bc6540d6-87c1-41a7-ae77-2347a7b17748" TYPE="xfs"
					/dev/nvme0n2p3: UUID="01560882-96a4-42f6-a0ad-26ebec0f6697" TYPE="ext4" PARTUUID="3df4e74c-19d9-194b-bad1-19f668a29e56"
					/dev/nvme0n2p1: PARTUUID="89e6da49-c9ea-5546-bc70-b2a3a74c0869"
					/dev/nvme0n2p2: UUID="84eb2ed6-06f8-47bf-819a-48164c510476" TYPE="ext4" PARTUUID="31b03148-5204-0b44-ad35-53d27a5b8330"
					/dev/mapper/rl-root: UUID="ccf4286e-6b47-47e8-bcda-06039a4ae70b" TYPE="xfs"
					
					#使用sda1的UUID挂载/dev/sda1
					987@hk987.xyz:~$ sudo mount UUID="6510A6455A6F759A" ~/sda1 

					#更改权限和取消挂载都是一样的，这里不再赘述
					987@hk987.xyz:~$ sudo chown -R 987:987 ~/sda1
					#如果不需要使用了，可以使用下面的命令取消挂载
					987@hk987.xyz:~$ sudo umount ~/sda1
					</code>
					</pre>

					<h3 id="Linux-fstab-11">a.编辑/etc/fstab文件实现自动挂载</h3>

					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#方法一：使用分区号自动挂载
					#使用vim编辑器打开这个文件
					987@hk987.xyz:~$ sudo vim /etc/fstab
					#在已有内容的后面新起一行，写入下面了内容；
					#一共分为6列，每列之间可以用空格或tab符分隔
					#第一个参数为你要挂载的分区(/dev/sda1)；
					#第二个参数为挂载的位置（/sda1文件夹必须存在）；
					#第三个参数是分区文件类型(在上面一个小节中，我们用mkfs将/dev/sda1格式化成了ntfs)；
					#后面的参数默认即可；
					/dev/sda1   /home/987/sda1  ntfs  defaults  0  0

					#保存退出，这样每次系统重启都会自动将/dev/sda1分区挂载到/home/987/sda1目录中了

					#方法二：使用/dev/sda1分区的UUID自动挂载
					987@hk987.xyz:~$ sudo vim /etc/fstab
					#在已有内容的后面新起一行，写入下面了内容；
					UUID="6510A6455A6F759A" /home/987/sda1  ntfs  defaults  0  0

					#列出mount分区列表（所有自动和手动挂载的分区都会被列出来）
					987@hk987.xyz:~$ mount
					</code>
					</pre>
					<p>使用/etc/fstab文件，每次重启，系统就会自动将fstab文件中指定的分区全部挂载上。</p>

					<h2 id="Linux-mkswap-12">0×6.创建SWAP分区</h2>

					<p>现在假设我们系统没有分配SWAP交换分区，而后我们想添加一个SWAP分区（或者扩充现有的SWAP分区大小），可以先使用fdisk从空余磁盘中取出一部分空间，然后激活成SWAP分区，请看下面的实例：</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#分区的步骤这里就不给出了，只是要注意在分区时使用t参数将分区类型替换成交换分区
					#在MBR分区表中，SWAP分区号是82
					#在GPT分区表中，SWAP分区号是19
					#现在假设我将上面分配的/dev/nvme0n2p1这个分区改成Linux swap分区
					#前面我们给/dev/nvme0n2这块M.2硬盘分区的时候用的是GPT分区表
					#注意：这一步是不必要的，也就意味着，不用更改分区类型也可以
					#建议：更改分区类型，这样在fdisk -l中能够一眼就看出哪个分区是swap分区
					987@hk987.xyz:~$ sudo fdisk /dev/nvme0n2
					命令(输入 m 获取帮助)：p
					Disk /dev/nvme0n2：20 GiB，21474836480 字节，41943040 个扇区
					磁盘型号：VMware Virtual NVMe Disk
					单元：扇区 / 1 * 512 = 512 字节
					扇区大小(逻辑/物理)：512 字节 / 512 字节
					I/O 大小(最小/最佳)：512 字节 / 512 字节
					磁盘标签类型：gpt
					磁盘标识符：9E261226-7289-F846-ABC5-370150C140F6

					设备               起点     末尾     扇区  大小 类型
					/dev/nvme0n2p1     2048 10487807 10485760    5G Linux 文件系统
					/dev/nvme0n2p2 10487808 10897407   409600  200M Linux 文件系统
					/dev/nvme0n2p3 10897408 41943006 31045599 14.8G Linux 文件系统

					#使用命令t更改分区类型
					命令(输入 m 获取帮助)：t
					分区号 (1-3, 默认  3): 1 #更改第一个分区
					分区类型或别名（输入 L 列出所有类型）：L #列出所有类型
					 ......
					 19 Linux swap   0657FD6D-A4AB-43C4-84E5-0933C84B4F4F
					 ......
					 :19  #直接输入查看到的swap编号19回车，更改成Linux swap类型

					已将分区“Linux filesystem”的类型更改为“Linux swap”。

					#查看到分区1类型已经更改
					命令(输入 m 获取帮助)：p
					设备               起点     末尾     扇区  大小 类型
					/dev/nvme0n2p1     2048 10487807 10485760    5G Linux swap
					/dev/nvme0n2p2 10487808 10897407   409600  200M Linux 文件系统
					/dev/nvme0n2p3 10897408 41943006 31045599 14.8G Linux 文件系统

					命令(输入 m 获取帮助)：w #保存退出
					分区表已调整。
					将调用 ioctl() 来重新读分区表。
					正在同步磁盘。

					#将/dev/nvme0n2p1格式化成swap分区
					987@hk987.xyz:~$ sudo mkswap /dev/nvme0n2p1
					#启用刚才格式化的swap分区
					987@hk987.xyz:~$ sudo swapon /dev/nvme0n2p1
					#查看系统中启用的swap分区（命令输出同：cat /proc/swaps）
					987@hk987.xyz:~$ swapon -s
					Filename                Type            Size               Used            Priority
					/dev/dm-1             partition     8220668         0               -2
					/dev/nvme0n2p1  partition     5242876         0               -3

					#除此之外，还可以通过free查看系统中的swap总量
					987@hk987.xyz:~$ free -h
					total        used       free      shared  buff/cache   available
					Mem:      7.5Gi       923Mi  6.3Gi        15Mi       544Mi       6.6Gi
					Swap:       12Gi       0B        12Gi
					</code>
					</pre>
					<p>如果不想使用这个swap分区了，可以使用下面的方法：</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#首先将这个swap分区停掉
					987@hk987.xyz:~$ sudo swapoff /dev/nvme0n2p1

					#再用fdisk将这个分区的类型改成Linux filesystem
					987@hk987.xyz:~$ sudo fdisk /dev/nvme0n2

					命令(输入 m 获取帮助)：t
					分区号 (1-3, 默认  3): 1
					#输入linux回车，这是“Linux filesystem”类型的别名
					分区类型或别名（输入 L 列出所有类型）：linux 

					已将分区“Linux filesystem”的类型更改为“Linux filesystem”。

					命令(输入 m 获取帮助)：w
					分区表已调整。
					将调用 ioctl() 来重新读分区表。
					正在同步磁盘。

					#最后再将这个分区格式化成ext4分区
					987@hk987.xyz:~$ sudo mkfs.ext4 /dev/nvme0n2p1
					 /dev/nvme0n2p1 有一个 swap 文件系统
					无论如何也要继续?（y,N) y #输入y回车
					</code>
					</pre>

					<h2 id="Linux-parted-13">0×7.linux如何使用parted进行硬盘分区管理</h2>
					<p>parted 是一个用于磁盘分区的命令行工具，它允许用户在Linux系统中创建、删除、调整和管理磁盘分区。  parted 可以用于创建各种类型的分区表，并支持多种文件系统类型。 </p>
					<p>以下是  parted 的一些主要特点和功能： </p>
 					<p class="indent-p">支持不同类型的分区表 ： parted 支持创建不同类型的分区表，包括传统的 MBR（Master Boot Record）分区表和现代的 GPT（GUID Partition Table）分区表；<br>
 					创建、调整和删除分区 ：使用  parted，你可以创建新的分区、调整现有分区的大小和位置，以及删除分区；<br> 
 					支持多种文件系统 ： parted 支持多种常见的文件系统类型，包括 ext2、ext3、ext4、NTFS、FAT32 等 ；<br>
 					灵活的命令行界面 ： parted 提供了一个灵活的命令行界面，允许用户交互式地执行分区操作，并提供了丰富的命令和选项； <br>
 					支持自动化操作 ：除了交互式操作外， parted 还支持在脚本中使用，可以用于自动化分区管理任务； <br>
 					跨平台支持 ： parted 是一个跨平台的工具，可以在多个操作系统上使用；</p>

					<p>★ 显示系统中所有的硬盘设备</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#使用管理员权限执行 parted -l 就能显示出系统中所有读取到的硬盘设备名称
					987@hk987.xyz:~$ sudo parted -l
					错误: /dev/sdb: 无法辨识的磁盘卷标
					型号：VMware, VMware Virtual S (scsi)                                     
					磁盘 /dev/sda：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：unknown
					磁盘标志：

					型号：ATA VMware Virtual I (scsi)
					磁盘 /dev/sda：32.2GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：msdos  #msdos就是MBR类型的分区表
					磁盘标志：

					编号  起始点  结束点  大小    类型      文件系统        标志
					 1    1049kB  10.7GB  10.7GB  primary   linux-swap(v1)
					 2    10.7GB  32.2GB  21.5GB  extended
					 5    10.7GB  16.1GB  5369MB  logical


					型号：VMware Virtual NVMe Disk (nvme)
					磁盘 /dev/nvme0n1：215GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：msdos
					磁盘标志：

					编号  起始点  结束点  大小    类型     文件系统  标志
					 1    1049kB  1075MB  1074MB  primary  xfs       启动
					 2    1075MB  215GB   214GB   primary            lvm


					型号：VMware Virtual NVMe Disk (nvme)
					磁盘 /dev/nvme0n2：21.5GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称  标志
					 1    1049kB  5370MB  5369MB  ext4
					 2    5370MB  5579MB  210MB   ext4
					 3    5579MB  21.5GB  15.9GB  ext4
					</code>
					</pre>
					<p>在我们这篇文章的所有实验中，还剩/dev/sdb这块SCSI接口的硬盘没有使用过，接下来就用这块硬盘来演示parted的用法。</p>
					<p>★ parted创建分区表</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#注意：parted操作硬盘是及时生效的，对新硬盘不会提示，但是对于已经存在分区表的硬盘会提示警告
					#一旦输入yes，更改就会生效，一定要看清楚再确定
					987@hk987.xyz:~$ sudo parted /dev/sdb
					[sudo] hk987 的密码：
					(parted) print  #打印当前硬盘分区表
					错误: /dev/sdb: 无法辨识的磁盘卷标
					型号：VMware, VMware Virtual S (scsi)                                     
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：unknown
					磁盘标志：

					(parted) mklabel gpt  #创建gpt分区表，可以简写成mkl gpt，如果想要创建MBR类型，可以mkl msdos
					(parted) p  #print可以简写成p
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt #分区表类型已经更改
					磁盘标志：

					编号  起始点  结束点  大小  文件系统  名称  标志

					(parted) quit  #退出，可以简写成q

					#再次进入prated命令模式
					987@hk987.xyz:~$ sudo parted /dev/sda                                
					(parted) mkl msdos  #尝试将分区表类型更改成MBR
					警告: 现有 /dev/sdb 上的磁盘卷标将被销毁，而所有在这个磁盘上的数据将会丢失。您要继续吗？
					是/Yes/否/No? yes  #给出警告，输入yes就会让更改生效，一定要看清楚再yes
					(parted) p                                                                
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：msdos
					磁盘标志：

					编号  起始点  结束点  大小  类型  文件系统  标志

					(parted) mkl gpt  #再重新将分区表更改成GPT
					警告: 现有 /dev/sdb 上的磁盘卷标将被销毁，而所有在这个磁盘上的数据将会丢失。您要继续吗？
					是/Yes/否/No? yes
					</code>
					</pre>

					<p>★ parted分区</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#现在来看看怎么用parted进行分区
					987@hk987.xyz:~$ sudo parted /dev/sdb
					#分区命令mkpart可以简写成mkp
					#mkp [分区标志] [分区文件系统类型] [起始点] [结束点]
					#按照这个语法，我们给分区起名叫hk987，类型为ext4，从硬盘的1M处开始划分空间，到5G处作为空间结束点
					(parted) mkp hk987 ext4 1M 5G

					(parted) p  #查看分区
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称  标志
					 1    1049kB  5000MB  4999MB  ext4      hk987

					 #再分配一个NTFS分区，从上一个分区的结束点（5G处）开始，到10G结束
					(parted) mkp hk987 ntfs 5G 10G

					(parted) p                                                                
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称  标志
					 1    1049kB  5000MB  4999MB  ext4      hk987
					 2    5000MB  10.0GB  5001MB  ntfs      hk987  msftdata

					 #除了上面的语法，还可以直接输出mkp，然后依次填入分区信息，如下
					(parted) mkp
					分区名称？  []? hk987                                                      
					文件系统类型？  [ext2]? ext4                                              
					起始点？ 10G  #注意，起始点一定要是上一个分区的结束点，用p命令可以查看到
					结束点？ 20G #相当于分配一个从10G-20G，也就是大小是10G的分区

					(parted) p                                                                
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称  标志
					 1    1049kB  5000MB  4999MB  ext4      hk987
					 2    5000MB  10.0GB  5001MB  ntfs      hk987  msftdata
					 3    10.0GB  20.0GB  9999MB  ext4      hk987

					 #如果我们想从上一个分区的结束点，直接分配一个分区占用整个硬盘剩余空间，可以使用100%参数
					(parted) mkp hk987 ext4 20G 100%

					(parted) p                                                                
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称  标志
					 1    1049kB  5000MB  4999MB  ext4      hk987
					 2    5000MB  10.0GB  5001MB  ntfs      hk987  msftdata
					 3    10.0GB  20.0GB  9999MB  ext4      hk987
					 4    20.0GB  42.9GB  22.9GB  ext4      hk987
					</code>
					</pre>

					<p>★ parted修改分区信息（标志，大小）</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#将编号为4的分区的标志修改成hk987
					(parted) name 4 hk987
					(parted) p
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称    标志
					 1    1049kB  5000MB  4999MB  ext4      hk987
					 2    5000MB  10.0GB  5001MB  ntfs      hk987    msftdata
					 3    10.0GB  20.0GB  9999MB  ext4      hk987
					 4    20.0GB  42.9GB  22.9GB  ext4      hk987 <--修改了这里

					 #修改分区大小，以分区4为例
					 #语法 resizepart [分区号] [结束点]
					 #将分区4缩小，结束点设置在30G
					 (parted) resizepart 4 30G
					警告: 缩小分区可导致数据丢失，你确定要继续吗？ [!!!注意，缩小分区会让数据丢失，慎用!!!]
					是/Yes/否/No? yes 

					(parted) p                                                                
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称    标志
					 1    1049kB  5000MB  4999MB            hk987
					 2    5000MB  10.0GB  5001MB            hk987    msftdata
					 3    10.0GB  20.0GB  9999MB            hk987
					 4    20.0GB  30.0GB  10.0GB  ext4      hk987

					 #扩大分区不会导致数据丢失，再将分区4扩大到结束点35G
					(parted) resizepart 4 35G  

					(parted) p                                                                
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称    标志
					 1    1049kB  5000MB  4999MB            hk987
					 2    5000MB  10.0GB  5001MB            hk987    msftdata
					 3    10.0GB  20.0GB  9999MB            hk987
					 4    20.0GB  35.0GB  15.0GB  ext4      hk987

					 #将最后一个分区4的大小扩充到占完整个硬盘空间
					(parted) resizepart 4 100%
					(parted) p                                                                
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称    标志
					 1    1049kB  5000MB  4999MB            hk987
					 2    5000MB  10.0GB  5001MB            hk987    msftdata
					 3    10.0GB  20.0GB  9999MB            hk987
					 4    20.0GB  42.9GB  23.0GB  ext4      hk987
					</code>
					</pre>

					<p>★ parted 删除分区</p>
					<pre data-prismjs-copy='复制代码' data-prismjs-copy-success='成功复制！'>
					<code class="language-bash">
					#使用rm命令加上分区号，删除分区1和分区3
					(parted) rm 1
					(parted) rm 3 
					                                                            
					(parted) p                                                                
					型号：VMware, VMware Virtual S (scsi)
					磁盘 /dev/sdb：42.9GB
					扇区大小 (逻辑/物理)：512B/512B
					分区表：gpt
					磁盘标志：

					编号  起始点  结束点  大小    文件系统  名称    标志
					 2    5000MB  10.0GB  5001MB            hk987    msftdata
					 4    20.0GB  42.9GB  23.0GB  ext4      hk987
					</code>
					</pre>

					<!-- /正文 -->

				<footer class="text-footer">
					<p>
						*转载请注明来自:<a title="hk987.xyz" style="color: rgb(4,181,150);" href="https://www.hk987.xyz" target="_blank">hk987.xyz</a>
					</p>
					<p>*原文连接:<a title="[Linux基础]-14-Linux硬盘分区管理" style="color: rgb(4,181,150);" href="https://www.hk987.xyz/hk/Linux-basic-14.html" target="_blank">https://www.hk987.xyz/hk/Linux-basic-14.html</a></p>
				</footer>
			</article>
			<!-- /文章区 -->	
		</div>
	</div>
	<!-- /content -->
	
	<!-- footer -->
	<footer id="footer">
		<div class="footer-container">
			hk987.xyz &nbsp;<img src="../logo/copyright.png" alt="未经作者允许,禁止任何形式的复制与转载" title="未经作者允许,禁止任何形式的复制与转载">&nbsp;All Rights Reserved.
		</div>
	</footer>
	<!-- /footer -->
</body>
</html>